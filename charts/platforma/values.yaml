replicaCount: 1

image:
  repository: your-application-repo/platforma
  pullPolicy: IfNotPresent
  tag: "latest" # or Chart.AppVersion

# -- Specify imagePullSecrets to use for pulling images from private registries.
# See: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
  # - name: regcred # Example: replace with the name of your image pull secret

serviceAccount:
  # -- Specifies whether a service account should be created
  create: true
  # -- The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template.
  name: ""
  # -- Annotations for the Service Account. Useful for linking with cloud provider IAM roles.
  annotations: {}
    # eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/my-platforma-iam-role
    # iam.gke.io/sa-name: my-platforma-gsa # For Workload Identity on GKE

service:
  type: ClusterIP # ClusterIP, NodePort, LoadBalancer
  port: 6345 # Matches --listen-port default
  # Optional: For LoadBalancer service, you might need:
  # loadBalancerIP: "" # Specific static IP for the load balancer
  # annotations: {} # e.g., for AWS ALB: "service.beta.kubernetes.io/aws-load-balancer-type": "nlb"

ingress:
  enabled: false
  className: "nginx" # Or your specific IngressClass (e.g., "gce", "traefik")
  annotations: {}
    # kubernetes.io/ingress.class: nginx # Older way of specifying ingress class
    # cert-manager.io/cluster-issuer: letsencrypt-prod # Example for cert-manager
  hosts:
    - host: chart-example.local # Replace with your actual domain
      paths:
        - path: /
          pathType: Prefix # Or Exact, ImplementationSpecific
          service:
            name: # Will be auto-generated to {{ include "your-app-name.fullname" . }}
            port: http # Refers to the name of the port in the service definition
  tls: [] # List of TLS secrets. Requires cert-manager or manually created secrets.
    # - secretName: chart-example-tls # Name of the Secret containing the TLS cert
    #   hosts:
    #     - chart-example.local

probes:
  liveness:
    enabled: true
    httpGet: # Assuming HTTP health check
      path: /health # Replace with your actual health check endpoint provided by platforma
      port: http # Refers to the name of the port in the service definition
    initialDelaySeconds: 30 # Initial delay before health checks begin
    periodSeconds: 10 # How often to perform the check
    timeoutSeconds: 5 # Timeout for the health check request
    successThreshold: 1 # Number of consecutive successes for the probe to be considered successful
    failureThreshold: 6 # Number of consecutive failures before restart (for liveness)
  readiness:
    enabled: true
    httpGet:
      path: /health # Replace with your actual health check endpoint
      port: http
    initialDelaySeconds: 10 # Shorter initial delay for readiness
    periodSeconds: 5 # More frequent checks for readiness
    timeoutSeconds: 3
    successThreshold: 1
    failureThreshold: 3 # Fewer failures before removing from service endpoints

# Environment Variables for the application container
env:
  # -- Simple key-value environment variables
  variables:
    # PLATFORMA_APP_ENV: "production"
    # FEATURE_TOGGLE_X: "true"

  # -- Environment variables populated from Kubernetes Secrets (recommended for sensitive data)
  # Ensure the referenced Secret exists in the same namespace.
  # See: https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-environment-variables
  secretVariables:
    # - name: DB_PASSWORD # Name of the environment variable in the container
    #   secretKeyRef:
    #     name: my-database-secret # Name of the Kubernetes Secret
    #     key: password # Key within the Secret that holds the value
    #     # optional: true # Set to true if the secret or its key can be missing (Kubernetes 1.20+)

    # - name: S3_ACCESS_KEY_ID # Example for S3 credentials from a secret
    #   secretKeyRef:
    #     name: platforma-s3-credentials
    #     key: access_key

    # - name: S3_SECRET_ACCESS_KEY # Example for S3 credentials from a secret
    #   secretKeyRef:
    #     name: platforma-s3-credentials
    #     key: secret_key

  # -- Environment variables populated from Kubernetes ConfigMaps (for non-sensitive configuration)
  # Ensure the referenced ConfigMap exists in the same namespace.
  # See: https://kubernetes.io/docs/concepts/configuration/configmap/#using-configmaps-as-environment-variables
  configMapVariables:
    # - name: APP_MODE # Name of the environment variable in the container
    #   configMapKeyRef:
    #     name: my-app-configmap # Name of the Kubernetes ConfigMap
    #     key: application_mode # Key within the ConfigMap that holds the value
    #     # optional: true # Set to true if the configmap or its key can be missing (Kubernetes 1.20+)

    # - name: PLATFORMA_API_BASE_URL
    #   configMapKeyRef:
    #     name: platforma-backend-config
    #     key: api_base_url

# Deployment-level configuration
deployment:
  priorityClassName: "" # Assigns a PriorityClass (e.g., "high-priority") to the Pod.
  schedulerName: ""     # Use an alternate scheduler, e.g., "stork-scheduler".
  # -- Only Pod's additional labels
  podLabels: {}
  # -- Only Pod's annotations (e.g., for Prometheus scraping)
  podAnnotations: {}
    # prometheus.io/scrape: "true"
    # prometheus.io/port: "6345" # Or your metric port
    # prometheus.io/scheme: "http"
  # -- Deployment strategy ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
  strategy:
    type: RollingUpdate # Or Recreate. RollingUpdate is generally preferred for zero-downtime updates.
    # If type is RollingUpdate:
    rollingUpdate:
      maxSurge: 25% # Max number of pods that can be created above desired count
      maxUnavailable: 25% # Max number of pods that can be unavailable during update
      # maxSurge: 1 # Example for fixed numbers
      # maxUnavailable: 0
  # -- Container-level security context.
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  securityContext:
    enabled: true # Set to false to disable applying this context
    privileged: true # Grants all capabilities. Use with extreme caution.
    runAsUser: 0 # Run as root user inside the container
    runAsGroup: 0 # Run as root group inside the container
    runAsNonRoot: false # Allow running as root user
    readOnlyRootFilesystem: false # Allow writing to the container's root filesystem
    allowPrivilegeEscalation: true # Allow processes to gain more privileges
    capabilities:
      add: ["ALL"] # Add all Linux capabilities. Use with extreme caution.
      drop: [] # Drop no capabilities. Consider dropping unnecessary capabilities.
  # -- Pod-level security context.
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  podSecurityContext:
    enabled: true # Set to false to disable applying this context
    fsGroup: 3000 # Group ID for volume ownership
    # Additional pod security context fields:
    # runAsUser: 1000 # If running as non-root
    # runAsGroup: 1000 # If running as non-root
    # runAsNonRoot: true # Set to true if runAsUser/runAsGroup are non-root
    # supplementalGroups: [1001, 1002] # Additional groups for the pod
    # seccompProfile: # Linux Seccomp profile
    #   type: RuntimeDefault # Or "Localhost" with specific path

# -- Sidecar Containers
# This section defines containers that run alongside your main application container.
# In Kubernetes v1.28+, native sidecar support is achieved by setting `restartPolicy: Always`
# on initContainers. These sidecars start before the main application container
# and remain running throughout its lifecycle, terminating gracefully after the main container exits.
# Useful for logging agents, monitoring exporters, network proxies, etc.
# See: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#sharing-volumes-with-sidecar-containers
sidecarContainers: []
  # - name: my-log-shipper
  #   image: fluent/fluentd:v1.16-debian-1.0
  #   imagePullPolicy: IfNotPresent
  #   command: ["fluentd", "-c", "/fluentd/etc/fluentd.conf"]
  #   restartPolicy: Always # Essential for native sidecar behavior
  #   volumeMounts:
  #     - name: log-dir-volume # Mount the application's log directory
  #       mountPath: /var/log/platforma # Fluentd will read logs from here
  #     # You'd also need a ConfigMap for fluentd.conf and mount it.
  #   resources:
  #     limits:
  #       cpu: 100m
  #       memory: 128Mi
  #     requests:
  #       cpu: 50m
  #       memory: 64Mi
  # - name: my-monitoring-exporter
  #   image: prom/node-exporter:latest
  #   imagePullPolicy: IfNotPresent
  #   command: ["node_exporter"]
  #   restartPolicy: Always
  #   resources:
  #     limits:
  #       cpu: 50m
  #       memory: 64Mi
  #     requests:
  #       cpu: 25m
  #       memory: 32Mi

# Main Options
mainOptions:
  config:
    enabled: false
    file: ""
  licenseFile:
    enabled: true
    path: "/root/.pl-license"
  license:
    enabled: false
    value: ""

# Local Storage Options (using PVCs as discussed)
persistence:
  globalEnabled: true
  mainRoot:
    enabled: true
    accessMode: ReadWriteOnce
    size: 10Gi
    # storageClass: "standard"
    mountPath: /data/platforma-data/instance
  dbDir:
    enabled: true
    accessMode: ReadWriteOnce
    size: 20Gi
    # storageClass: "standard"
    mountPath: /data/rocksdb
  workDir:
    enabled: true
    accessMode: ReadWriteOnce
    size: 50Gi
    # storageClass: "standard"
    mountPath: /data/platforma-data/work
  packagesDir:
    enabled: true
    accessMode: ReadWriteOnce
    size: 50Gi
    # storageClass: "standard"
    mountPath: /data/platforma-data/packages

# Logging Options
loggingOptions:
  logDir:
    enabled: true
    accessMode: ReadWriteOnce
    size: 5Gi
    # storageClass: "standard"
    mountPath: /data/log
  quiet: false
  logLevel: info
  logRotationSize: 20MiB
  logRotationBackups: 20
  noLogRotation: false
  noLogCompression: false

# Listen Options
listenOptions:
  port: 6345
  ip: "0.0.0.0"
  tls:
    enabled: false
    certPath: ""
    keyPath: ""
    org: "Platforma"
    domains: []
    ips: []

# Primary Storage Options (S3)
primaryStorage:
  s3:
    enabled: true
    url: "https://storage.googleapis.com/milab-prod-platforma-bucket/milab/"
    region: "europe-west3"
    key: "" # It's better to use SecretKeyRef for sensitive keys
    secret: "" # It's better to use SecretKeyRef for sensitive secrets
    externalEndpoint: ""
    noDataIntegrity: false

# Data Library Options
dataLibrary:
  noDataLibrary: false
  fs: []
  s3:
    - id: "library"
      enabled: true
      url: "https://storage.googleapis.com/milab-prod-platforma-bucket/corp-library/"
      region: "europe-west3"
      key: "" # It's better to use SecretKeyRef for sensitive keys
      secret: "" # It's better to use SecretKeyRef for sensitive secrets
      externalEndpoint: ""
      noDataIntegrity: false

# Runner Options
runnerOptions:
  localCpu: ""
  localRam: ""

# Authentication Options
authOptions:
  htpasswd:
    enabled: false
    path: ""
  ldap:
    enabled: false
    server: ""
    dn: ""
    startTls: false

# Special Options
specialOptions:
  cancelRunningBlocks: false
  useRestrictedNetworkMode: false

# Google Batch
googleBatch:
  enabled: false
  storage: "/data/platforma-data=nfs://YOUR_NFS_SERVER/pl_shared_fs"
  network: "projects/YOUR_PROJECT/global/networks/YOUR_VPC"
  subnetwork: "projects/YOUR_PROJECT/regions/europe-west3/subnetworks/YOUR_SUBNET"
  provisioning: "SPOT"

# Pod Disruption Budget
pdb:
  enabled: false
  minAvailable: 1 # Or maxUnavailable: "25%"

# Horizontal Pod Autoscaler
hpa:
  enabled: false
  minReplicas: 1 # Must be >= replicaCount
  maxReplicas: 5
  targetCPUUtilization: 80 # Target CPU utilization (percentage)

# -- Network Policy settings
# See: https://kubernetes.io/docs/concepts/services-networking/network-policies/
networkPolicy:
  # -- Enable or disable the creation of NetworkPolicy resource.
  # Requires a NetworkPolicy-enabled CNI plugin (e.g., Calico, Cilium, Weave Net).
  enabled: false
  # -- Specify the policy types.
  # This defaults to ["Ingress", "Egress"] but can be overridden.
  policyTypes:
    - Ingress
    - Egress
  # -- Ingress rules for the application.
  # By default, denies all ingress traffic unless explicitly allowed.
  # Allow traffic from:
  # - Pods in the same namespace with specific labels
  # - Pods in other namespaces
  # - IP blocks
  ingress: []
    # - from:
    #     - podSelector: {} # Allow all pods in the same namespace
    #     - namespaceSelector: {} # Allow all pods in all namespaces
    # - from: # Allow traffic from other pods in the same namespace with specific labels
    #   - podSelector:
    #       matchLabels:
    #         app.kubernetes.io/name: my-other-app
    #         app.kubernetes.io/instance: my-release
    # ports: # Specify ports that traffic is allowed on
    #   - protocol: TCP
    #     port: 6345 # Allow HTTP traffic to the application port

  # -- Egress rules for the application.
  # By default, denies all egress traffic unless explicitly allowed.
  # Allow traffic to:
  # - Pods in the same namespace
  # - Pods in other namespaces
  # - IP blocks (e.g., external databases, cloud APIs)
  egress: []
    # - to:
    #     - ipBlock:
    #         cidr: 0.0.0.0/0 # Allow all outbound traffic (caution: broad access)
    #   ports:
    #     - protocol: TCP
    #       port: 80
    #     - protocol: TCP
    #       port: 443
    # - to: # Allow egress to DNS services (crucial for most applications)
    #     - namespaceSelector: {} # Select all namespaces (for DNS in kube-system)
    #       podSelector:
    #         matchLabels:
    #           k8s-app: kube-dns # Example selector for default CoreDNS/kube-dns
    #   ports:
    #     - protocol: UDP
    #       port: 53

resources:
  limits:
    cpu: 1000m
    memory: 2Gi
  requests:
    cpu: 500m
    memory: 1Gi

nodeSelector: {}
affinity: {}
tolerations: []